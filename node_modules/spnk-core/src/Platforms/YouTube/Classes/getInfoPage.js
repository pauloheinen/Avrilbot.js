"use strict";
const B_URL = 'https://www.youtube.com/watch?v=';
const Utils = require('./Utils.js');
const getChannelInfo = require('../getChannelInfo.js');
const {getVideoID} = require('../getID.js');
const getWatchHTMLPageBody = (id) => Utils.RequestExp(`${B_URL + id}&hl=en`);
class getINFO {
    #getVideoInfoPage = (url) => {
        try {
            return new Promise(async (res) => {
                let id = getVideoID(url);
                let body = await getWatchHTMLPageBody(id);
                let response = Utils.FindPlayerRes(body);

                if (!response || !response.videoDetails || !response.streamingData) return res({meta: null, code: 404});
                if (response.playabilityStatus.status === 'ERROR') return res({meta: null, code: response.playabilityStatus?.code});

                let html5player = new URL(Utils.getHTML5player(body), B_URL).toString();
                let findFormats = response.streamingData ? response.streamingData.adaptiveFormats : [];
                let Formats = [];

                if (response.streamingData && response.streamingData.hlsManifestUrl) {
                    let url = response.streamingData.hlsManifestUrl;
                    Formats.push(Utils.getM3U8(url));
                } else {
                    Formats.push(Utils.getFormats(findFormats, html5player));
                }

                if (response.videoDetails && response.videoDetails.thumbnail) {
                    response.videoDetails.thumbnail = response.videoDetails.thumbnail.thumbnails.sort((a, b) => (b.width - a.width))[0];
                }
                let results = await Promise.all(Formats);
                Formats = Object.values(Object.assign({}, ...results));

                return res({
                    meta: {
                        id: response.videoDetails.videoId,
                        title: response.videoDetails.title,
                        url: `https://www.youtube.com/watch?v=${response.videoDetails.videoId}`,
                        author: await getChannelInfo(response.videoDetails),
                        duration: {
                            seconds: response.videoDetails.lengthSeconds
                        },
                        thumbnails: response.videoDetails.thumbnail,
                        isLive: response.videoDetails.isLiveContent,
                        isUpcoming: !!response.videoDetails.isUpcoming && response.playabilityStatus.status.toUpperCase() !== 'OK',
                        isPremium: response.playabilityStatus.status.toUpperCase() !== 'OK' && !Formats,
                        isValid: true,
                        isAgeLimit: !response.streamingData,
                        formats: Formats
                    },
                    code: 200
                });
            });
        } catch (e) {
            return null;
        }
    };
    getInfo = (id) => {
        return new Promise((resolve) => {
            this.#getVideoInfoPage(id).then(info => {
                if (info.code === 404) return resolve({isValid: false, code: info.code || undefined});
                else if (info.code !== 200) return resolve({isValid: undefined, code: info.code || undefined});
                return resolve(info.meta);
            })
        });
    };
}
module.exports = new getINFO();