"use strict";
const querystring = require('querystring');
const Request = require('../../../Global/Request.js');

class Utils {
    FindPlayerRes = (body) => {
        let jsonStr = JSON.parse(body.split("var ytInitialPlayerResponse = ")[1].split("}};")[0] + '}}');
        if (!jsonStr) return {};
        return jsonStr;
    };
    getHTML5player = (body) => {
        let html5playerRes = /<script\s+src="([^"]+)"(?:\s+type="text\/javascript")?\s+name="player_ias\/base"\s*>|"jsUrl":"([^"]+)"/.exec(body);
        return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;
    };
    RequestExp = (url) => {
        return new Promise((res) => {
            Request.makeRequest(url, {headers: {'cookie': process.env.YTcookie}}).then(resp => {
                if (resp.error) return res(null);
                return res(resp.text());
            }).then(resp2 => {return res(resp2)});
        })
    };
    getFormats = async (formats, html5player) => {
        let Formats = {};
        let tokens = await this.getTokens(html5player);
        formats.forEach(format => {
            let cipher = format.signatureCipher || format.cipher;
            if (cipher) {
                Object.assign(format, querystring.parse(cipher));
                delete format.signatureCipher;
                delete format.cipher;
            }
            let sig = tokens && format.s ? this.decipher(tokens, format.s) : null;
            this.setDownloadURL(format, sig);
            Formats[format.url] = {
                itag: format.itag,
                playable: format.quality === 'tiny' && format.mimeType.match(/audio/) ? true : 'VideoOnly',
                video: {
                    type: format.mimeType.split("/")[1].split("codecs=")[0].replace(/[\s",/,;]/g, '').toUpperCase(),
                    quality: format.qualityLabel || null,
                    fps: format.fps || null,
                    size: `${format.width || 0}x${format.height || 0}`
                },
                audio: {
                    codec: format.mimeType.split("codecs=")[1].replace(/[\s",/]/g, ''),
                    quality: format.audioQuality ? format.audioQuality.split('AUDIO_QUALITY_')[1] : null,
                    bitrate: format.bitrate,
                    SampleRate: format.audioSampleRate || null,
                    Channels: format.audioChannels || null
                },
                range: {
                    init: format.initRange,
                    index: format.indexRange
                },
                url: format.url
            };
        });
        return Formats;
    };
    getM3U8 = async (url) => {
        url = new URL(url, 'https://www.youtube.com/watch?v=');
        let body = (await this.RequestExp(url.toString())), formats = {};
        body.split('\n').filter(line => /^https?:\/\//.test(line)).forEach(line => {
            let other = parseInt(line.match(/\/itag\/(\d+)\//)[1]);
            formats[line] = {other, url: line};
        });
        return formats;
    };
    setDownloadURL = (format, sig) => {
        let decodedUrl;
        if (format.url) decodedUrl = format.url;
        else return;

        try {
            decodedUrl = decodeURIComponent(decodedUrl);
        } catch (err) {
            return;
        }
        let parsedUrl = new URL(decodedUrl);
        parsedUrl.searchParams.set('ratebypass', 'yes');
        if (sig) parsedUrl.searchParams.set(format.sp || 'signature', sig);
        format.url = parsedUrl.toString();
    };
    decipher = (tokens, sig) => {
        sig = sig.split('');
        for (let i = 0, len = tokens.length; i < len; i++) {
            let token = tokens[i], pos;
            switch (token[0]) {
                case 'r':
                    sig = sig.reverse();
                    break;
                case 'w':
                    pos = ~~token.slice(1);
                    sig = this.swapHeadAndPosition(sig, pos);
                    break;
                case 's':
                    pos = ~~token.slice(1);
                    sig = sig.slice(pos);
                    break;
                case 'p':
                    pos = ~~token.slice(1);
                    sig.splice(0, pos);
                    break;
            }
        }
        return sig.join('');
    };
    swapHeadAndPosition = (arr, position) => {
        let first = arr[0];
        arr[0] = arr[position % arr.length];
        arr[position] = first;
        return arr;
    };
    getTokens = async (html5playerfile) => {
        let body = (await this.RequestExp(html5playerfile)), tokens = extractActions(body);
        if (!tokens || !tokens.length) throw Error('Could not extract signature deciphering actions');
        return tokens;
    };
}
module.exports = new Utils();


const jsVarStr = '[a-zA-Z_\\$][a-zA-Z_0-9]*',
    jsSingleQuoteStr = `'[^'\\\\]*(:?\\\\[\\s\\S][^'\\\\]*)*'`,
    jsDoubleQuoteStr = `"[^"\\\\]*(:?\\\\[\\s\\S][^"\\\\]*)*"`,
    jsQuoteStr = `(?:${jsSingleQuoteStr}|${jsDoubleQuoteStr})`,
    jsKeyStr = `(?:${jsVarStr}|${jsQuoteStr})`,
    jsPropStr = `(?:\\.${jsVarStr}|\\[${jsQuoteStr}\\])`,
    jsEmptyStr = `(?:''|"")`,
    reverseStr = ':function\\(a\\)\\{' + '(?:return )?a\\.reverse\\(\\)' + '\\}',
    sliceStr = ':function\\(a,b\\)\\{' + 'return a\\.slice\\(b\\)' + '\\}',
    spliceStr = ':function\\(a,b\\)\\{' + 'a\\.splice\\(0,b\\)' + '\\}',
    swapStr = ':function\\(a,b\\)\\{' + 'var c=a\\[0\\];a\\[0\\]=a\\[b(?:%a\\.length)?\\];a\\[b(?:%a\\.length)?\\]=c(?:;return a)?' + '\\}',
    actionsObjRegexp = new RegExp(`var (${jsVarStr})=\\{((?:(?:${jsKeyStr}${reverseStr}|${jsKeyStr}${sliceStr}|${jsKeyStr}${spliceStr}|${jsKeyStr}${swapStr}),?\\r?\\n?)+)\\};`),
    actionsFuncRegexp = new RegExp(`${`function(?: ${jsVarStr})?\\(a\\)\\{` + `a=a\\.split\\(${jsEmptyStr}\\);\\s*` + `((?:(?:a=)?${jsVarStr}`}${jsPropStr}\\(a,\\d+\\);)+)` + `return a\\.join\\(${jsEmptyStr}\\)` + `\\}`),
    reverseRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${reverseStr}`, 'm'),
    sliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${sliceStr}`, 'm'),
    spliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${spliceStr}`, 'm'),
    swapRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${swapStr}`, 'm');

const extractActions = (body) => {
    let objResult = actionsObjRegexp.exec(body),
        funcResult = actionsFuncRegexp.exec(body);
    if (!objResult || !funcResult) { return null; }

    let obj = objResult[1].replace(/\$/g, '\\$'),
        objBody = objResult[2].replace(/\$/g, '\\$'),
        funcBody = funcResult[1].replace(/\$/g, '\\$');

    let result = reverseRegexp.exec(objBody);
    let reverseKey = result && result[1].replace(/\$/g, '\\$').replace(/\$|^'|^"|'$|"$/g, '');
    result = sliceRegexp.exec(objBody);
    let sliceKey = result && result[1].replace(/\$/g, '\\$').replace(/\$|^'|^"|'$|"$/g, '');
    result = spliceRegexp.exec(objBody);
    let spliceKey = result && result[1].replace(/\$/g, '\\$').replace(/\$|^'|^"|'$|"$/g, '');
    result = swapRegexp.exec(objBody);
    let swapKey = result && result[1].replace(/\$/g, '\\$').replace(/\$|^'|^"|'$|"$/g, '');

    let keys = `(${[reverseKey, sliceKey, spliceKey, swapKey].join('|')})`;
    let myreg = `(?:a=)?${obj}(?:\\.${keys}|\\['${keys}'\\]|\\["${keys}"\\])` + `\\(a,(\\d+)\\)`;
    let tokenizeRegexp = new RegExp(myreg, 'g');
    let tokens = [];
    while ((result = tokenizeRegexp.exec(funcBody)) !== null) {
        let key = result[1] || result[2] || result[3];
        switch (key) {
            case swapKey:
                tokens.push(`w${result[4]}`);
                break;
            case reverseKey:
                tokens.push('r');
                break;
            case sliceKey:
                tokens.push(`s${result[4]}`);
                break;
            case spliceKey:
                tokens.push(`p${result[4]}`);
                break;
        }
    }
    return tokens;
};