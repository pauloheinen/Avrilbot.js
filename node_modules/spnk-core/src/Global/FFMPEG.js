"use strict";
const ChildProcess = require('child_process');
const { Duplex, PassThrough } = require('stream');
const data = {file: null, yt: null, m3u8: null};

class Setup_FFmpeg {
    //Codecs
    OggOpus = ["-acodec", "libopus", "-f", "opus"];
    _m3u8 = ["-c:v", "libx264"];
    _Video = ["-c:v", "copy", "-c:a", "aac"];
    EncoderChannel = ["-ar", 48e3, "-ac", 2];
    //
    Other = ["-analyzeduration", 0, "-loglevel", 0]
    Reconnect = ["-reconnect", 1, "-reconnect_streamed", 1, "-reconnect_delay_max", 1];
    noLossFrame = ["-preset", "slow", "-crf", 0, "-qscale", 1 << 25];
    bassboost = ["-af", "bass=g=8"];

    //Public Function
    File = (File, options) => {
        options = this.#ChangeOptions(options);
        let Args = this.#ChangeArgs(true, null, options);
        return this.#SpawnFFmpeg(Args, File, options);
    };
    Url = (format, options) => {
        options = this.#ChangeOptions(options);
        let Args = this.#ChangeArgs(false, format, options);
        return this.#SpawnFFmpeg(Args, null, options);
    };
    m3u8 = (format, options) => {
        options = this.#ChangeOptions(options);
        let Args = this.#ChangeArgs('m3u8', format, options);
        return this.#SpawnFFmpeg(Args, null, options);
    };
    Video = (format, options) => {
        let Args = [...this.Reconnect, '-i', format.video, ...this.Reconnect, '-i', format.audio, ...this._Video, ...this.noLossFrame, `${options.name}.${options.format}`];
        return this.#SpawnFFmpeg(Args, null, options, false);
    };

    //Local Function
    #ChangeArgs = (isFile = false, format = null, options) => {
        if (options.FFmpegArgs && Array.isArray(options.FFmpegArgs)) return [...options.FFmpegArgs];

        let Args = [...this.Reconnect];

        if (isFile === true) Args = [...Args];
        else if (!isFile) Args = [...Args, '-i', format.url];
        else Args = [...Args, '-i', format.url, ...this._m3u8];

        if (options.encoderOptions.seek > 0) Args = [...Args, '-ss', options.encoderOptions.seek];
        if (options.encoderOptions.to && isFile !== 'm3u8') Args = [...Args, '-to', options.encoderOptions.to];

        if (options.encoderOptions.bassboost) Args = [...Args, ...this.bassboost];
        if (options.encoderOptions.noLossFrame || isFile === 'm3u8') Args = [...Args, ...this.noLossFrame];

        return this.#ChangeCodec([...Args, ...this.Other], options);
    };
    #ChangeCodec = (Args, options) => {
        if (options.codec) Args = [...Args, ...options.codec];
        else Args = [...Args, ...this.OggOpus];
        return [...Args, ...this.EncoderChannel];
    }
    #ChangeOptions = (options) => {
        if (!options.encoderOptions) options.encoderOptions = {seek: 0, bassboost: false, noLossFrame: false, to: 0};
        if (!options.FFmpegArgs) options.FFmpegArgs = null;
        return options;
    };
    #SpawnFFmpeg = (Args, isFile = false, options, isPipe = true) => {
        let transcoder = new FFmpeg({args: Args, shell: !1, isPipe: isPipe});
        let stream = new PassThrough({ highWaterMark: (options.highWaterMark || 25) });

        if (isFile) {
            let inputStream = isFile.on("error", () => transcoder.kill());
            let outputStream = inputStream.pipe(transcoder);

            return toStream(outputStream);
        } else return toStream(transcoder);

        //
        function toStream(req) {
            ["info", "progress", "abort", "request", "response", "error", "redirect", "retry", "reconnect"].forEach((event) => {
                req.prependListener(event, stream.emit.bind(stream, event));
            });
            req.pipe(stream, {end: true});

            stream.isKilled = req.isKilled;
            stream.kill = () => {
                if (stream.destroyed) stream.destroy();
                req.kill();
            }
            return req.on('close', () => {
                    if (!req.isKilled) req.kill();
                    if (stream.destroyed) stream.destroy();
                }
            ), stream;
        }
    };
}
module.exports = {
    Url: (format, options) => Object.assign(new Setup_FFmpeg().Url(format, options), data.yt),
    File: (File, options) => Object.assign(new Setup_FFmpeg().File(File, options), data.file),
    m3u8: (format, options) => Object.assign(new Setup_FFmpeg().m3u8(format, options), data.m3u8),
    DownloadVideo: (format, options) => Object.assign(new Setup_FFmpeg().Video(format, options), data.yt)
};

class FFmpeg extends Duplex {
    constructor(options = {}) {
        super();
        this.process = this.#create(options);
        let EVENTS = {
            readable: this._reader,
            data: this._reader,
            end: this._reader,
            unpipe: this._reader,
            finish: this._writer,
            drain: this._writer,
        };

        this._readableState = this._reader._readableState;
        this._writableState = this._writer._writableState;

        this.kill = () => { this.process.kill(); };
        this.isKilled = this.process.killed;

        this.#_copy(['write', 'end'], this._writer);
        this.#_copy(['read', 'setEncoding', 'pipe', 'unpipe'], this._reader);

        for (let method of ['on', 'once', 'removeListener', 'removeListeners', 'listeners']) {
            this[method] = (ev, fn) => EVENTS[ev] ? EVENTS[ev][method](ev, fn) : Duplex.prototype[method].call(this, ev, fn);
        }

        let processError = e => this.emit('error', e);
        this._reader.on('error', processError);
        this._writer.on('error', processError);
    };

    get _reader() { return this.process.stdout; };
    get _writer() { return this.process.stdin; };

    #_copy(methods, target) {
        for (let method of methods) this[method] = target[method].bind(target);
    };
    #getInfo() {
        let sources = [() => {
            let ffmpegStatic = require('ffmpeg-static');
            return ffmpegStatic.path || ffmpegStatic || process.env.FFmpeg;
        }, 'ffmpeg', 'avconv', './ffmpeg', './avconv', './.ffmpeg/ffmpeg', './.ffmpeg/avconv'];

        for (let source of sources) {
            try {
                return (typeof source === 'function') ? source() : source;
            } catch (e) {/* Do nothing */}
        }
        throw new Error('FFmpeg/avconv not found!');
    };
    #create(options) {
        if (!options.args.includes('-i')) options.args = [...options.args, "-i", "-"];
        if (options.isPipe) options.args = [...options.args, "pipe:"];
        return ChildProcess.spawn(this.#getInfo(), options.args, { windowsHide: true, shell: options.shell});
    };
}