const voice = require('@discordjs/voice');
const {createAdapter} = require('../adapter.js');
const ytdl = require('discord-ytdl-core');
const {EventEmitter} = require('events');

const wait = (ms) => new Promise((resolve, reject) => {setTimeout(resolve, ms);});

function connect(connection){
    return new Promise(async (resolve, reject) => {
        try{
            await voice.entersState(connection, voice.VoiceConnectionStatus.Ready, 30e3);
            resolve();
        } catch(error) {
            connection.destroy();
            reject(error);
        }
    });
}

class Player extends EventEmitter {
    /**
    * Creates a music player to play your songs in
    * @param {object} channel The channel to play music in
    * @example
    * const player = new Player(<channel>);
    */
    constructor(channel){

        if(channel === undefined || typeof channel === "undefined" || channel === "") throw Error(`Channel is required`);
        super();
        this.channel = channel;

        this.player = voice.createAudioPlayer({
            behaviors: {
                noSubscriber: voice.NoSubscriberBehavior.Play
            }
        });
        
    }
    /**
    * To play a song in a voice channel.
    * @param {string} stream The stream to play in the voice channel.
    * @param {object} options Optional options.
    * @returns {Promise<string>} Returns an error if the connection failed.
    * 
    * @example
    * player.play('https://www.youtube.com/watch?v=dQw4w9WgXcQ', {
    *     autoleave: true,
    *     quality: 'high',
    *     selfDeaf: true,
    *     selfMute: false
    * })
    * .then(() => console.log(`Playing the song`))
    * .catch(console.error);
    * */
    async play(stream, options = {autoleave: false, quality: 'low', selfDeaf: true, selfMute: false}){
        return new Promise((resolve, reject) => {
            if(stream === undefined || typeof stream === "undefined" || stream === "") return reject(`Stream is required`);

            this.stream = stream;
            this.settings = {
                autoleave: false,
                quality: 'low',
                selfDeaf: true,
                selfMute: false,
                youtube: null
            };
            const yturl = ytdl.validateURL(stream) ? true : false;
            if(options){
                if(typeof options.autoleave === 'boolean') this.settings['autoleave'] = Boolean(options.autoleave);
                if(typeof options.selfDeaf === 'boolean') this.settings['selfDeaf'] = Boolean(options.selfDeaf);
                if(typeof options.selfMute === 'boolean') this.settings['selfMute'] = Boolean(options.selfMute);
                if(typeof options.quality === 'string') this.settings['quality'] = options.quality.toLowerCase() === 'high' ? options.quality : 'low';
                this.settings['youtube'] = yturl;
            }

            if(this.playing === true){
                this.playing = false;
            }
            if(this.settings.youtube === false){
                this.resource = voice.createAudioResource(this.stream, {
                    inputType: voice.StreamType.Arbitrary,
                    inlineVolume: true
                });
                this.resource.playStream.on('end', () => {
                    this.emit('stop');
                    this.playing = false;
                    if(this.settings['autoleave'] === true) if(voice.getVoiceConnection(this.channel.guild.id)) voice.getVoiceConnection(this.channel.guild.id).disconnect();
                });
                this.resource.encoder.on('error', error => {
                    reject(error);
                });
                this.player.play(this.resource);
                voice.entersState(this.player, voice.AudioPlayerStatus.Playing, 5e3);
            } else {
                ytdl.getInfo(this.stream).then(info => {
                    const download = ytdl.downloadFromInfo(info, {
                        quality: (this.settings.quality === 'high' ? 'highestaudio' : 'lowestaudio'),
                        filter: 'audioonly',
                        highWaterMark: 1048576 * 32
                    });
                    download.on('error', error => {
                        this.playing = false;
                        reject(error);
                    });
                    this.resource = voice.createAudioResource(download, {
                        inputType: voice.StreamType.Arbitrary,
                        inlineVolume: true
                    });
                    this.resource.playStream.on('end', () => {
                        this.emit('stop');
                        this.playing = false;
                        if(this.settings['autoleave'] === true) if(voice.getVoiceConnection(this.channel.guild.id)) voice.getVoiceConnection(this.channel.guild.id).disconnect();
                    });
                    this.player.play(this.resource);
                    voice.entersState(this.player, voice.AudioPlayerStatus.Playing, 5e3);

                }).catch(err => {
                    this.playing = false;
                    reject(err);
                })
            }
            if(this.connection === undefined || this.connected === false){
                const connection = voice.joinVoiceChannel({
                    channelId: this.channel.id,
                    guildId: this.channel.guild.id,
                    adapterCreator: createAdapter(this.channel),
                    selfDeaf: this.settings.selfDeaf,
                    selfMute: this.settings.selfMute
                });
                connect(connection).then(() => {
                    this.subscribtion = connection.subscribe(this.player);
                    this.connection = connection;
                    this.connected = true;
                    this.subscribtion.player.on('subscribe', () => {
                        this.emit('play');
                        this.playing = true;
                    });
                    this.subscribtion.player.on('unsubscribe', () => {
                        if(this.playing === false) return;
                        this.playing = false;
                        this.connected = false;
                        this.emit('stop');
                    });
                    connection.on(voice.VoiceConnectionStatus.Disconnected, () => {
                        if(this.playing === false) return;
                        this.playing = false;
                        this.connected = false;
                        this.emit('disconnect');
                    });
                    connection.on(voice.VoiceConnectionStatus.Destroyed, () => {
                        if(this.playing === false) return;
                        this.playing = false;
                        this.connected = false;
                        this.emit('destroy');
                    });
                    resolve();
                }).catch(err => {
                    this.playing = false;
                    reject(err);
                });
            } else {
                this.subscribtion = this.connection.subscribe(this.player);
                this.emit('play');
                resolve();
            }
        });
    }
    /**
     * Destroys the voice connection.
     * @example
     * player.destroy();
     */
    destroy(){
        this.connection.destroy();
    }
    /**
     * Disconnects with the voice connection.
     * @example
     * player.disconnect();
     */
    disconnect(){
        this.connection.disconnect();
    }
    /**
     * Reconnects to a voice connection.
     * @param {number} timeout How many miliseconds the bot needs to wait before connecting to the voice connection again. Default is 2000 miliseconds.
     * @returns {Promise} Returns an error if the connection failed
     * @example
     * player.reconnect(3000)
     *   .then(() => console.log(`Successfully reconnected`))
     *   .catch(console.error);
     */
    reconnect(timeout){
        return new Promise(async (resolve, reject) => {
            this.connection.destroy();
            await wait(timeout || 2000);
            const connection = voice.joinVoiceChannel({
                channelId: this.channel.id,
                guildId: this.channel.guild.id,
                adapterCreator: createAdapter(this.channel)
            });
            connect(connection).then(() => {
                this.subscribtion = connection.subscribe(this.player);
                this.connection = connection;
                this.playing = true;
                resolve();
            }).catch(err => {
                reject(err);
                this.playing = false;
            });
        });
    }
    /**
     * Pauses the song that's playing.
     * @example
     * player.pause();
     */
    pause(){
        this.subscribtion.player.pause();
    }
    /**
     * Resumes a song that has been paused.
     * @example
     * player.resume();
     */
    resume(){
        this.subscribtion.player.unpause();
    }
    /**
     * Checks if the song is playable.
     * @returns {Boolean} Returns true if the song is playable, returns false if the song is not playable.
     * @example
     *  if(player.getStatus() === true) console.log(`The song is playable!`);
     *  else console.log(`The song is not playable!`);
     */
    getStatus(){
        return this.subscribtion.player.checkPlayable();
    }
    /**
     * Gets the amount of members in the same voice channel with the bot
     * @returns {number} The amount of members in the voice channel
     */
    getListeners(){
        return this.channel.members.size;
    }
    /**
     * Changes the volume of the song
     * @param {number | string} volume The volume of the song
     * @example
     * player.volume("3/20"); // Sets the volume to 3/20
     * player.volume(3); // Sets the volume to 3/10
     */
    volume(volume){
        if(typeof volume !== "string" && typeof volume !== "number") throw Error(`Invalid type of volume`);
        if(typeof volume === "number"){
            if(volume > 10) throw Error(`Volume can't be higher than 10`);
            this.resource.volume.setVolumeLogarithmic(volume / 10);
        } else {
            let volumestring = volume;
            if(!volumestring.includes("/")) volumestring += "/ 10";
            let vol = volumestring.split("/");
            if(Number(vol[0]) > Number(vol[1])) throw Error(`Invalid type of volume`);
            this.resource.volume.setVolumeLogarithmic(Number(vol[0]) / Number(vol[1]));
        }
    }
}

module.exports = Player;