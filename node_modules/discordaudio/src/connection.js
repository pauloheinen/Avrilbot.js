const voice = require('@discordjs/voice');
const {EventEmitter} = require('events');
const {createAdapter} = require('../adapter.js');

function connect(connection){
    return new Promise(async (resolve, reject) => {
        try{
            await voice.entersState(connection, voice.VoiceConnectionStatus.Ready, 30e3);
            resolve();
        } catch (error) {
            connection.destroy();
            reject(error);
        }
    });
};

class Connection extends EventEmitter {
    /**
     * Creates a voice connection with a voice channel.
     * @param channel The voice channel to play a stream in.
     * @param {object} options Optional options.
     * @example
     * const connection = new Connection(<channel>, {
     *   selfDeaf: true,
     *   selfMute: false
     * });
     */
    constructor(channel, options = {selfDeaf: true, selfMute: false}){
        if(typeof channel === 'undefined' || channel === undefined || channel === "") throw new Error(`Channel is required`);
        super();

        this.channel = channel;

        this.settings = {
            selfDeaf: true,
            selfMute: false
        };

        if(options){
            if(typeof options.selfDeaf === 'boolean') this.settings.selfDeaf = options.selfDeaf;
            if(typeof options.selfMute === 'boolean') this.settings.selfMute = options.selfMute;
        }

        this.connection = voice.joinVoiceChannel({
            channelId: this.channel.id,
            guildId: this.channel.guild.id,
            adapterCreator: createAdapter(this.channel),
            selfDeaf: this.settings.selfDeaf,
            selfMute: this.settings.selfMute
        });
    }
    /**
     * 
     * @param {string} stream The stream to play in the voice connection.
     * @param {object} options Optional options.
     * @returns {Promise} Returns an error if there was an error while connecting to the voice channnel.
     * @example
     * connection.play('https://somecoolsite.com/somereallycoolstream.mp3', {
     *   noListeners: 'play', // What to do if there are no members in the voice channel
     *   volume: 1 // The volume of the stream, max volume is 1
     * })
     * .then(() => console.log(`The stream is playing!`))
     * .catch(console.error);
     */
    play(stream, options = {noListeners: 'pause', volume: 1}){
        return new Promise((resolve, reject) => {
            if(typeof stream === 'undefined' || stream === undefined || stream === "") return reject(new Error(`Stream is required`));

            var volume = 1;
            var noSubscriberBehavior = voice.NoSubscriberBehavior.Pause;

            if(options){
                if(options.noListeners){
                    if(options.noListeners.toLowerCase() === 'pause') noSubscriberBehavior = voice.NoSubscriberBehavior.Pause;
                    else if(options.noListeners.toLowerCase() === 'play') noSubscriberBehavior = voice.NoSubscriberBehavior.Play;
                    else if(options.noListeners.toLowerCase() === 'stop') noSubscriberBehavior = voice.NoSubscriberBehavior.Stop;
                }

                if(options.volume){
                    if(isNaN(options.volume)) throw new Error(`Volume is not a number`);
                    else if(options.volume > 1) throw new Error(`Volume may not be higher than 1`);
                    else volume = options.volume;
                }
            }

            const player = voice.createAudioPlayer({
                behaviors: {
                    noSubscriber: noSubscriberBehavior
                }
            });

            this.player = player;
                
            const resource = voice.createAudioResource(stream, {
                inputType: voice.StreamType.Arbitrary,
                inlineVolume: true
            });
            resource.volume.setVolume(volume);

            this.resource = resource;

            this.resource.playStream.on('end', () => {
                this.emit('end');
            });

            this.player.play(this.resource);
            voice.entersState(this.player, voice.AudioPlayerStatus.Playing, 5e3);

            connect(this.connection).then(() => {
                this.connection.subscribe(this.player);
                this.type = 'stream';
                this.connection.on(voice.VoiceConnectionStatus.Disconnected, () => {
                    this.emit('disconnect');
                });
                this.connection.on(voice.VoiceConnectionStatus.Destroyed, () => {
                    this.emit('destroy');
                });
                this.emit('play');
                resolve();
            }).catch(err => {
                reject(err);
            });
        });
    }
    /**
     * Plays a broadcast in the voice connection. You can create a broadcast by using the Broadcast class.
     * @param broadcast The broadcast to play.
     * @returns {Promise} Returns an error if there is an error.
     * @example
     * connection.subscribe(<broadcast>)
     * .then(() => console.log(`Successfully started playing the broadcast`))
     * .catch(console.error);
     */
    subscribe(broadcast){
        return new Promise((resolve, reject) => {
            if(typeof broadcast === 'undefined' || broadcast === undefined || broadcast === "") throw new Error(`Broadcast is required`);

            this.broadcast = broadcast;
            connect(this.connection).then(() => {
                this.subscribtion = this.connection.subscribe(this.broadcast.player);
                this.type = 'broadcast';
                this.emit('subscribe');
                this.connection.on(voice.VoiceConnectionStatus.Disconnected, () => {
                    this.emit('disconnect');
                });
                this.connection.on(voice.VoiceConnectionStatus.Destroyed, () => {
                    this.emit('destroy');
                });
                this.emit('play');
                resolve();
            }).catch(err => {
                reject(err);
            });
        });
    }
    /**
     * Unsubscribes to an broadcast.
     * @example
     * connection.unsubscribe();
     */
    unsubscribe(){
        this.subscribtion.unsubscribe();
        this.emit('unsubscribe');
    }
    /**
     * Changes the volume of the stream. Does NOT work for broadcasts.
     * @param {number} volume The volume of the stream.
     * @example
     * connection.volume(0.6); // Sets the volume to 0.6
     */
    volume(volume){
        if(this.type === `broadcast`) throw new Error(`You can not change the volume for a broadcast in a connection`);
        if(typeof volume === 'undefined' || volume === undefined || volume === "") throw new Error(`Volume is required`);
        if(isNaN(volume)) throw new Error(`Volume is not a number`);
        else if(volume > 1) throw new Error(`Volume may not be higher than 1`);

        this.resource.volume.setVolume(volume);
    }
    /**
     * Disconnects to the voice connection.
     * @example
     * connection.disconnect();
     */
    disconnect(){
        if(this.type === `broadcast`) this.subscribtion.unsubscribe();
        this.connection.disconnect();
    }
    /**
     * Destroys the voice connection.
     * @example
     * connection.destroy();
     */
    destroy(){
        if(this.type === 'broadcast') this.subscribtion.unsubscribe();
        this.connection.destroy();
    }
    /**
     * Pauses the stream. This does NOT work for broadcasts.
     * @example
     * connection.pause();
     */
    pause(){
        if(this.type !== 'stream') return;

        this.player.pause();
    }
    /**
     * Resumes the stream if it is paused. This does NOT work for broadcasts.
     * @example
     * connection.resume();
     */
    resume(){
        if(this.type !== 'stream') return;

        this.player.unpause();
    }
};

module.exports = Connection;